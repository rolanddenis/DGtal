#include <cstring>
#include <algorithm>

namespace
{
  template < bool V >
  struct Boolean
    {
      enum { value = V };
    };

  template < std::size_t A, std::size_t B >
  struct IsDivisibleBy : Boolean< (A % B == 0) >
    {};

  template < std::size_t A, std::size_t B >
  struct IsGreaterThan : Boolean< (A > B) >
    {};

  template < std::size_t A, std::size_t B >
  struct IsLessThan : Boolean< (A < B) >
    {};

  template <
    std::size_t S,
    std::size_t N,
    bool IsSmallerThanAWord,
    bool IsLargerThanAWord,
    bool DivideAWord,
    bool IsDivisibleByAWord
  >
  struct BitFieldArrayImpl;

  // When the stored data has a size multiple of a word
  template < std::size_t S, std::size_t N, bool IsLargerThanAWord, bool DivideAWord >
  struct BitFieldArrayImpl< S, N, false, IsLargerThanAWord, DivideAWord, true >
    {
      template < typename Integer >
      static inline
      void getValue( std::size_t i, Integer const* data, Integer* result )
        {
          std::memcpy(
                      reinterpret_cast<void*>(result),
                      reinterpret_cast<void const*>( data + i * (S/(8*sizeof(Integer))) ),
                      S/8
          );

        }

      template < typename Integer >
      static inline
      void setValue( std::size_t i, Integer* data, Integer const* value )
        {
          std::memcpy(
                      reinterpret_cast<void*>( data + i * (S/(8*sizeof(Integer))) ),
                      reinterpret_cast<void const*>(value),
                      S/8
          );
        }
    };

  // When the stored data has a size that divide a word
  template < std::size_t S, std::size_t N >
  struct BitFieldArrayImpl< S, N, true, false, true, false >
    {
      template < typename Integer >
      static inline
      void getValue ( std::size_t i, Integer const* data, Integer* result )
        {
          const std::size_t word_index = (i*S) / (8*sizeof(Integer));
          const std::size_t word_pos   = (i*S) % (8*sizeof(Integer));
          *result = DGtal::Bits::wideCopyToStart( data[word_index], word_pos, *result, S );
        }

      template < typename Integer >
      static inline
      void setValue ( std::size_t i, Integer* data, Integer const* value )
        {
          const std::size_t word_index = (i*S) / (8*sizeof(Integer));
          const std::size_t word_pos   = (i*S) % (8*sizeof(Integer));
          data[word_index] = DGtal::Bits::wideCopyFromStart( *value, data[word_index], word_pos, S );
        }
    };

  // When the stored data has a size smaller than a word and that do no divide it.
  template < std::size_t S, std::size_t N >
  struct BitFieldArrayImpl< S, N, true, false, false, false >
    {
      template < typename Integer >
      static inline
      void getValue ( std::size_t i, Integer const* data, Integer* result )
        {
          const std::size_t word_index = (i*S) / (8*sizeof(Integer));
          const std::size_t word_pos   = (i*S) % (8*sizeof(Integer));
          const std::size_t result_length = 8*sizeof(Integer) - word_pos;
          *result = DGtal::Bits::wideCopyToStart( data[word_index], word_pos, *result, S );

          if ( result_length < S )
            {
              *result = DGtal::Bits::wideCopyFromStart( data[word_index+1], *result, result_length, S - result_length );
            }
        }

      template < typename Integer >
      static inline
      void setValue ( std::size_t i, Integer* data, Integer const* value )
        {
          const std::size_t word_index = (i*S) / (8*sizeof(Integer));
          const std::size_t word_pos   = (i*S) % (8*sizeof(Integer));
          const std::size_t result_length = 8*sizeof(Integer) - word_pos;
          data[word_index] = DGtal::Bits::wideCopyFromStart( *value, data[word_index], word_pos, S );

          if ( result_length < S )
            {
              data[word_index+1] = DGtal::Bits::wideCopyToStart( *value, result_length, data[word_index+1], S - result_length );
            }
        }
    };

  // When the stored data has a size larger than a word and is not a multiple of a word.
  template < std::size_t S, std::size_t N >
  struct BitFieldArrayImpl< S, N, false, true, false, false >
    {
      template < typename Integer >
      static inline
      void getValue( std::size_t i, Integer const* data, Integer* result )
        {
          data += (i*S) / (8*sizeof(Integer));
          std::size_t data_pos   = (i*S) % (8*sizeof(Integer));
          std::size_t value_pos  = 0;
          std::size_t copy_left = S;

          while ( copy_left > 0 )
            {
              const std::size_t copy_length =
                  std::min(
                      copy_left,
                      8*sizeof(Integer) - std::max( data_pos, value_pos )
              );

              if ( copy_length == 8*sizeof(Integer) )
                {
                  *result = *data;
                  copy_left -= copy_length;
                  ++data;
                  ++result;
                }
              else
                {
                  *result = DGtal::Bits::wideCopy( *data, data_pos, *result, value_pos, copy_length );

                  copy_left -= copy_length;
                  data    += ( copy_length == 8*sizeof(Integer) - data_pos )  ? 1 : 0;
                  result  += ( copy_length == 8*sizeof(Integer) - value_pos ) ? 1 : 0;
                  data_pos  = ( data_pos + copy_length )  % (8*sizeof(Integer));
                  value_pos = ( value_pos + copy_length ) % (8*sizeof(Integer));
                }
            }
        }

      template < typename Integer >
      static inline
      void setValue( std::size_t i, Integer* data, Integer const* value )
        {
          data += (i*S) / (8*sizeof(Integer));
          std::size_t data_pos   = (i*S) % (8*sizeof(Integer));
          std::size_t value_pos  = 0;
          std::size_t copy_left = S;

          while ( copy_left > 0 )
            {
              const std::size_t copy_length =
                  std::min(
                      copy_left,
                      8*sizeof(Integer) - std::max( data_pos, value_pos )
              );

              if ( copy_length == 8*sizeof(Integer) )
                {
                  *data = *value;
                  copy_left -= copy_length;
                  ++data;
                  ++value;
                }
              else
                {
                  *data = DGtal::Bits::wideCopy( *value, value_pos, *data, data_pos, copy_length);

                  copy_left -= copy_length;
                  data    += ( copy_length == 8*sizeof(Integer) - data_pos )  ? 1 : 0;
                  value   += ( copy_length == 8*sizeof(Integer) - value_pos ) ? 1 : 0;
                  data_pos  = ( data_pos + copy_length )  % (8*sizeof(Integer));
                  value_pos = ( value_pos + copy_length ) % (8*sizeof(Integer));
                }
            }
        }
    };

  template <
    std::size_t S,
    std::size_t N,
    typename Integer
  >
  struct BitFieldArrayImplDispatch
      : BitFieldArrayImpl< S, N,
          IsLessThan< S, 8*sizeof(Integer) >::value,
          IsGreaterThan< S, 8*sizeof(Integer) >::value,
          IsDivisibleBy< 8*sizeof(Integer), S >::value,
          IsDivisibleBy< S, 8*sizeof(Integer) >::value
        >
    {
    };


} // anonymous namespace

namespace DGtal
{

template < typename T, std::size_t S, std::size_t N >
inline
T BitFieldArray<T,S,N>::getValue( std::size_t i ) const
{
  Value result;
  BitFieldArrayImplDispatch< S, N, Integer >
    ::getValue(
               i,
               reinterpret_cast<Integer const*>(myMemory),
               reinterpret_cast<Integer*>(&result)
  );

  return result;
}

template < typename T, std::size_t S, std::size_t N >
inline
void BitFieldArray<T,S,N>::setValue( std::size_t i, Value const& value )
{
  BitFieldArrayImplDispatch < S, N, Integer >
    ::setValue(
               i,
               reinterpret_cast<Integer*>(myMemory),
               reinterpret_cast<Integer const*>(&value)
  );

}

} // namespace DGtal

