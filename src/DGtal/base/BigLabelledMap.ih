/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file BigLabelledMap.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2012/07/05
 *
 * Implementation of inline methods defined in BigLabelledMap.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// class BigLabelledMap
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
DGtal::BigLabelledMap<TData, L, N, M>::
BigLabelledMap()
{ // default constructor of myLabels and myFirstBlock is automatically called.
  myFirstBlock.myLabels.setValue(0, 0);
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
DGtal::BigLabelledMap<TData, L, N, M>::
~BigLabelledMap()
{
  myFirstBlock.clear( size() );
}

#if 0
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
DGtal::BigLabelledMap<TData, L, N, M>::
BigLabelledMap( const BigLabelledMap & other )
  : myLabels( other.myLabels ),
    myFirstBlock( other.myFirstBlock )
{
  const unsigned int theSize = other.size();
  if ( theSize > N + 1 )
    {
      unsigned int s = N;
      const __AnyBlock* nextBlock = other.myFirstBlock.data.nextBlock;
      __AnyBlock** currentPointer = & myFirstBlock.data.nextBlock;
      while ( s < theSize )
        {
          *currentPointer = new __AnyBlock( *nextBlock );
          s += M;
          currentPointer = & ( (*currentPointer)->next );
          nextBlock = nextBlock->next;
        }
    }
}
#endif

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
template <typename InputIterator>
inline
DGtal::BigLabelledMap<TData, L, N, M>::
BigLabelledMap( InputIterator first, InputIterator last )
{ // default constructor of myLabels and myFirstBlock is automatically called.
  BOOST_CONCEPT_ASSERT(( boost::InputIterator< InputIterator > ));
  myFirstBlock.myLabels.setValue( 0, 0);
  for ( ; first != last; ++first )
    {
      myFirstBlock.pushBack( *first, size() );
      setSize( size() + 1 );
    }
}

#if 0
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
DGtal::BigLabelledMap<TData, L, N, M> &
DGtal::BigLabelledMap<TData, L, N, M>::
operator=( const BigLabelledMap & other )
{
  if ( this != &other )
    {
      blockClear( size() );
      myLabels = other.myLabels;
      myFirstBlock = other.myFirstBlock;

      const unsigned int theSize = other.size();
      if ( theSize > N + 1 )
        {
          unsigned int s = N; 
          const __AnyBlock* nextBlock = other.myFirstBlock.data.nextBlock;
          __AnyBlock** currentPointer = & myFirstBlock.data.nextBlock;
          while ( s < theSize  )
            {
              *currentPointer = new __AnyBlock( *nextBlock );
              s += M;
              currentPointer = & ( (*currentPointer)->next );
              nextBlock = nextBlock->next;
            }
        }
    }
  return *this;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
clear()
{
  blockClear( size() );
  myLabels.reset();
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
blockClear( unsigned int theSize )
{
  if ( theSize != N+1 )
    {
      __AnyBlock* nextBlock = myFirstBlock.data.nextBlock;
      while ( nextBlock != 0 )
        {
          __AnyBlock* ptr = nextBlock;
          nextBlock = nextBlock->next;
          delete ptr;
        }
    }
  myFirstBlock.data.nextBlock = 0;
}

#endif

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
size() const
{
  return myFirstBlock.myLabels.getValue(0, SizeType(0));
}

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
bool
DGtal::BigLabelledMap<TData, L, N, M>::
empty() const
{
  return size() == 0;
}

#if 0
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
max_size() const
{
  return MaxLabel;
}

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
capacity() const
{
  return ( size() <= (N+1) )
    ? N+1
    : ( 1 + ( size() - 1 - N ) / M ) * M + N;
}

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::KeyCompare
DGtal::BigLabelledMap<TData, L, N, M>::
key_comp() const
{
  return KeyCompare();
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ValueCompare
DGtal::BigLabelledMap<TData, L, N, M>::
value_comp() const
{
  return ValueCompare();
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
swap( Self & other )
{
  std::swap( myLabels, other.myLabels );
  std::swap( myFirstBlock, other.myFirstBlock );
}

#endif
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
count( const Key & key ) const
{
  const ConstIterator it_end = end();
  
  return ( std::find( begin(), it_end, key ) == end() ) ? 0 : 1;
}

#if 0
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
const typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
blockAt( unsigned int idx ) const
{
  ASSERT( idx < size() );
  if ( idx < N )
    return myFirstBlock.datas[ idx ];
  else if ( ( idx == N ) && ( size() == N+1 ) )
    return myFirstBlock.data.lastData;
  const __AnyBlock* ptr = myFirstBlock.data.nextBlock;
  idx -= N;
  while ( idx >= M )
    {
      idx -= M;
      ptr = ptr->next;
    }
  ASSERT( ptr != 0 );
  return ptr->datas[ idx ];
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
blockAt( unsigned int idx )
{
  ASSERT( idx < size() );
  if ( idx < N )
    return myFirstBlock.datas[ idx ];
  else if ( ( idx == N ) && ( size() == N+1 ) )
    return myFirstBlock.data.lastData;
  __AnyBlock* ptr = myFirstBlock.data.nextBlock;
  idx -= N;
  while ( idx >= M )
    {
      idx -= M;
      ptr = ptr->next;
    }
  ASSERT( ptr != 0 );
  return ptr->datas[ idx ];
}

#endif

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
const typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
operator[]( const Key & key ) const
{
  ASSERT( key < L ); 
  bool exists = myLabels.test( key );
  if ( ! exists ) 
    {
      unsigned int block_size = size();
      myLabels.set( key ); // must be done before so that 'index' works.
      return blockInsert( myLabels.index( key ), block_size, Data() );
    }
  else
    {
      return blockAt( myLabels.index( key ) );
    }
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
operator[]( const Key & key )
{
  ASSERT( key < L ); 
  bool exists = myLabels.test( key );
  if ( ! exists ) 
    {
      unsigned int block_size = size();
      myLabels.set( key ); // must be done before so that 'index' works.
      return blockInsert( myLabels.index( key ), block_size, Data() );
    }
  else
    {
      return blockAt( myLabels.index( key ) );
    }
}

#if 0
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
const typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
fastAt( const Key & key ) const
{
  ASSERT( key < L ); 
  ASSERT( myLabels.test( key ) );
  return blockAt( myLabels.index( key ) );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
fastAt( const Key & key )
{
  ASSERT( key < L ); 
  ASSERT( myLabels.test( key ) );
  return blockAt( myLabels.index( key ) );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
erase( Iterator position )
{
  Key key = (*position).first;
  ASSERT( myLabels.test( key ) );
  blockErase( myLabels.index( key ) );
  myLabels.reset( key );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
erase( Key key )
{
  if ( myLabels.test( key ) )
    {
      blockErase( myLabels.index( key ) );
      myLabels.reset( key );
      return 1;
    }
  return 0;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
erase( Iterator first, Iterator last )
{
  for ( ; first != last; ++first )
    erase( first );
}

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
std::pair<typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator, bool>
DGtal::BigLabelledMap<TData, L, N, M>::
insert( const Value & val )
{
  ASSERT( val.first < L ); 
  bool exists = myLabels.test( val.first );
  if ( ! exists ) 
    {
      unsigned int block_size = size();
      myLabels.set( val.first ); // must be done before so that 'index' works.
      blockInsert( myLabels.index( val.first ), block_size, val.second );
    }
  Iterator position = begin();
  while ( (*position).first != val.first ) 
    {
      // std::cerr << "[" << (*position).first << "]" << std::endl;
      ++position;
    }
  return std::make_pair( position, exists );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
insert ( Iterator position, const Value & val )
{
  ASSERT( val.first < L ); 
  if ( ! myLabels.test( val.first ) )
    {
      unsigned int block_size = size();
      myLabels.set( val.first ); // must be done before so that 'index' works.
      blockInsert( myLabels.index( val.first ), block_size, val.second );
    }
  position = begin(); 
  while ( (*position).first != val.first ) 
    {
      //std::cerr << "[" << (*position).first << "]" << std::endl;
      ++position;
    }
  return position;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
template <typename InputIterator>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
insert( InputIterator first, InputIterator last )
{ 
  BOOST_CONCEPT_ASSERT(( boost::InputIterator< InputIterator > ));
  for ( ; first != last; ++first )
    {
      Key k = first->first;
      if ( ! myLabels.test( k ) )
        {
          unsigned int block_size = size();
          myLabels.set( k ); // must be done before so that 'index' works.
          blockInsert( myLabels.index( k ), block_size, first->second );
        }
    }
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
std::pair< typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator,
           typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator >
DGtal::BigLabelledMap<TData, L, N, M>::
equal_range( const Key & x )
{
  Iterator it = begin(), it_end = end();
  for ( ; it != it_end; ++it )
    {
      if ( (*it).first == x )
        { 
          // JOL: g++ does not compile correctly:
          // return std::make_pair( it, ++it );
          it_end = it; ++it_end;
          return std::make_pair( it, it_end );
        }
      else if ( (*it).first > x ) return std::make_pair( it, it );
    }
  return std::make_pair( it_end, it_end );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
std::pair< typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator,
           typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator >
DGtal::BigLabelledMap<TData, L, N, M>::
equal_range( const Key & x ) const
{
  ConstIterator it = begin(), it_end = end();
  for ( ; it != it_end; ++it )
    {
      if ( (*it).first == x ) return std::make_pair( it, ++it );
      else if ( (*it).first > x ) return std::make_pair( it, it );
    }
  return std::make_pair( it_end, it_end );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
find( const Key & x )
{
  Iterator it = begin(), it_end = end();
  for ( ; it != it_end; ++it )
    {
      if ( (*it).first == x ) return it;
      else if ( (*it).first > x ) return it_end;
    }
  return it_end;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
find( const Key & x ) const
{
  ConstIterator it = begin(), it_end = end();
  for ( ; it != it_end; ++it )
    {
      if ( (*it).first == x ) return it;
      else if ( (*it).first > x ) return it_end;
    }
  return it_end;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
lower_bound( const Key & x )
{
  Iterator it = begin(), it_end = end();
  for ( ; it != it_end; ++it )
    {
      if ( (*it).first >= x ) return it;
    }
  return it_end;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
lower_bound( const Key & x ) const
{
  ConstIterator it = begin(), it_end = end();
  for ( ; it != it_end; ++it )
    {
      if ( (*it).first >= x ) return it;
    }
  return it_end;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
upper_bound( const Key & x )
{
  Iterator it = begin(), it_end = end();
  for ( ; it != it_end; ++it )
    {
      if ( (*it).first > x ) return it;
    }
  return it_end;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
upper_bound( const Key & x ) const
{
  ConstIterator it = begin(), it_end = end();
  for ( ; it != it_end; ++it )
    {
      if ( (*it).first > x ) return it;
    }
  return it_end;
}

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
blockInsert( unsigned int idx, unsigned int block_size, const Data & data )
{
  ASSERT( idx <= block_size ); // end is ok.
  return myFirstBlock.insert( idx, block_size, data );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
blockErase( unsigned int idx )
{
  ASSERT( idx < size() ); // end is not ok.
  myFirstBlock.erase( idx, size() );
}

#endif
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
begin()
{
  return Iterator( myFirstBlock, size(), 0 );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
end()
{
  return Iterator( myFirstBlock, size(), size() );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
begin() const
{
  return ConstIterator( myFirstBlock, size(), 0 );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
end() const
{
  return ConstIterator( myFirstBlock, size(), size() );
}

#if 0
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::BlockIterator
DGtal::BigLabelledMap<TData, L, N, M>::
blockBegin()
{
  return BlockIterator( myFirstBlock, 0, size() );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::BlockIterator
DGtal::BigLabelledMap<TData, L, N, M>::
blockEnd()
{
  SizeType s = size();
  return BlockIterator( myFirstBlock, s, s );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::BlockConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
blockBegin() const
{
  return BlockConstIterator( myFirstBlock, 0, size() );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::BlockConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
blockEnd() const
{
  SizeType s = size();
  return BlockConstIterator( myFirstBlock, s, s );
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
selfDisplay( std::ostream & out ) const
{
  if ( size() == 0 ) out << "()";
  else
    {
      ConstIterator it = begin();
      ConstIterator it_end = end();
      out << "( ";
      out << "(" << (*it).first << "," << (*it).second << ")";
      ++it;
      for ( ; it != it_end; ++it )
	{
          out << ",(" << (*it).first << "," << (*it).second << ")";
	}
      out << " )";
    }
    // {
    //   BlockConstIterator it = blockBegin();
    //   BlockConstIterator it_end = blockEnd();
    //   BlockConstIterator it_last = it;
    //   out << "(";
    //   out << *it;
    //   ++it;
    //   for ( ; it != it_end; ++it )
    //     {
    //       out << ( ( it_last.myDatas == it.myDatas ) ? ',' : ';' );
    //       out << *it;
    //       it_last = it;
    //     }
    //   out << ")";
    // }
}


/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
bool
DGtal::BigLabelledMap<TData, L, N, M>::isValid() const
{
    return true;
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TData, unsigned int L, unsigned int N, unsigned int M>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const BigLabelledMap<TData, L, N, M> & object )
{
  object.selfDisplay( out );
  return out;
}
#endif

template <typename TData>
std::pair< unsigned int, unsigned int >
DGtal::detail::argminBigLabelledMapMemoryUsageForGeometricDistribution
( unsigned int L, double prob_no_data, double prob_one_data )
{
  unsigned int sL = 2 * ( ( ( L - 1 ) / 16 ) + 1 ); // word of 16bits
  // std::cerr << "L=" << L  << " sL=" << sL << std::endl;
  BigLabelledMapMemFunctor F( prob_one_data, prob_no_data, sL, sizeof( TData ),
                           sizeof( TData* ), 2 );
  double m = -1.0;
  unsigned int Nopt = 0;
  unsigned int Mopt = 0;
  for ( unsigned int N = 1; N < L; ++N )
    for ( unsigned int M = 2; M < (L-N); ++M )
      {
        // std::cerr << "Fmem(" << N << "," << M << ")=" 
        //           << F.fctNM( N, M ) << std::endl;
        if ( ( m < 0.0 ) || ( F.fctNM( N, M ) < m ) )
          {
            Nopt = N; Mopt = M; 
            m = F.fctNM( Nopt, Mopt );
          }
      }
  return std::make_pair( Nopt, Mopt );
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


