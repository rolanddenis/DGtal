/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file BigLabelledMap.ih
 * @author Roland Denis (\c roland.denis@univ-smb.fr )
 * LAboratory of MAthematics - LAMA (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2015/11/10
 *
 * Implementation of inline methods defined in BigLabelledMap.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <stdexcept>
#include <deque>
#include <iterator> // back_inserter
#include <algorithm> 
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// class BigLabelledMap::__Block
//-----------------------------------------------------------------------------

/** Represents any block of data in the container.
 * @tparam blockCapacity  The capacity of this block (without extra space).
 * @tparam labelArrayShift  Padding length at start of labels storage (=1 for the first block).
 */
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
template <std::size_t BlockCapacity, std::size_t LabelArrayShift>
struct DGtal::BigLabelledMap<TData, L, N, M>::__Block
{
  BOOST_STATIC_CONSTANT( std::size_t, blockCapacity = BlockCapacity ); ///< Capacity of this block.
  BOOST_STATIC_CONSTANT( std::size_t, labelArrayShift = LabelArrayShift ); ///< Unused label space.
  BOOST_STATIC_CONSTANT( std::size_t, extraSpace = sizeof(TData*)/sizeof(TData) ); ///< Extra space for storing values when the pointer is not used.
  BOOST_STATIC_CONSTANT( std::size_t, blockMaxCapacity = blockCapacity + extraSpace ); ///< Capacity of this block with extra space.

  typedef BitFieldArray< Label, labelSize, blockMaxCapacity + labelArrayShift >  Labels; ///< Label array.

  /// Used in any block to finish it or to point to the next block.
  union DataOrBlockPointer
    {
      Data lastData[extraSpace]; // used when at the end of the list
      __NextBlock* nextBlock;  // used otherwise
    };

  /// Constructor.
  __Block()
    {
      myTail.nextBlock = 0;
    }

  /** Returns true if the there is a next block
   * @param size  the current number of stored values in this block and the following.
   */
  static inline
  bool hasNextBlock( std::size_t size )
    {
      return size > blockMaxCapacity;
    }

  /** Returns true if the data at given index is stored in this block.
   * @param idx   the position of the data.
   * @param size  the current number of stored values in this block and the following.
   */
  static inline
  bool isInThisBlock( std::size_t idx, std::size_t size )
    {
      return size <= blockMaxCapacity || idx < blockCapacity;
    }

  /** Returns the number of stored values in this block
   * @param size  the current number of stored values in this block and the following.
   */
  static inline
  std::size_t blockSize( std::size_t size )
    {
      return (size <= blockMaxCapacity) ? size : blockCapacity;
    }

  /** Returns the label at position idx in the current block.
   * @param idx   the position where to read the label.
   */
  inline
  Label getBlockLabel( std::size_t idx ) const
    {
      ASSERT( idx < blockMaxCapacity );
      return myLabels.getValue( idx + labelArrayShift );
    }

  /** Returns the label at position idx, whatever the block where it is.
   * @param idx   the position where to read the label.
   * @param size  the current number of stored values in this block and the following.
   */
  inline
  Label getLabel( std::size_t idx, std::size_t size ) const
    {
      ASSERT( idx < size );
      if ( isInThisBlock( idx, size ) )
        {
          return getBlockLabel( idx );
        }
      else
        {
          return myTail.nextBlock->getLabel( idx - blockCapacity, size - blockCapacity );
        }
    }

  /** Sets the label at position idx in the current block.
   * @param idx   the position where to store the label.
   * @param label the label.
   */
  inline
  void setBlockLabel( std::size_t idx, Label label )
    {
      ASSERT( idx < blockMaxCapacity );
      myLabels.setValue( idx + labelArrayShift, label );
    }

  /** Sets the label at position idx, whatever the block where it is (the block must exists).
   * @param idx     the position where to store the label.
   * @param label   the label.
   * @param size    the current number of stored values in this block and the following.
   */
  inline
  void setLabel( std::size_t idx, Label label, std::size_t size )
    {
      ASSERT( idx < size );
      if ( isInThisBlock( idx, size ) )
        {
          setBlockLabel( idx );
        }
      else
        {
          myTail.nextBlock->setLabel( idx - blockCapacity, size - firstBlockSize );
        }
    }

  /** Sets a label and data at given position in this block.
   * @param idx   the position where to write.
   * @param label the label.
   * @param data  the data.
   * @return a reference to the written data.
   */
  inline
  Data& setBlockValueAt( std::size_t idx, Label const& label, Data const& data )
    {
      ASSERT( idx < blockMaxCapacity );
      setBlockLabel(idx, label);
      return ( myData[idx] = data ); // Works also if we use extra space.
    }

  /** Sets a (label,data) pair at given position in this block.
   * @param idx   the position where to write.
   * @param value the (label,data) pair.
   * @return a reference to the written data.
   */
  inline
  Data& setBlockValueAt( std::size_t idx, Value const& value )
    {
      return setBlockValueAt( idx, value.first, value.second );
    }

  /** Gets a constant (label,data) pair from given position in this block.
   * @param idx   the position where to read.
   * @return the (label,data) pair.
   */
  inline
  ConstReference getBlockValueAt( std::size_t idx ) const
    {
      ASSERT( idx < blockMaxCapacity );
      return ConstReference( getBlockLabel(idx), myData[idx] );
    }
  
  /** Gets a (label,data) pair, where the data is mutable, from given position in this block.
   * @param idx   the position where to read.
   * @return the (label,data) pair.
   */
  inline
  Reference getBlockValueAt( std::size_t idx )
    {
      ASSERT( idx < blockMaxCapacity );
      return Reference( getBlockLabel(idx), myData[idx] );
    }

  /** Get a data from given position in this block.
   * @param idx   the position where to read.
   * @return a mutable reference to the data.
   */
  inline
  Data& getBlockDataAt( std::size_t idx )
    {
      ASSERT( idx < blockMaxCapacity );
      return myData[idx];
    }

  /** Get a data from given position in this block.
   * @param idx   the position where to read.
   * @return a constant reference to the data.
   */
  inline
  Data const& getBlockDataAt( std::size_t idx ) const
    {
      ASSERT( idx < blockMaxCapacity );
      return myData[idx];
    }

  // Forward declaration.
  //inline
  //Data& pushBack( Value const& value, std::size_t size );

  /** Adds a data with given label.
   * @param label   the label.
   * @param data    the data.
   * @param size    the current number of stored values in this block and the following.
   */
  inline
  Data& pushBack( Label const& label, Data const& data, std::size_t size )
    {
      if ( size < blockMaxCapacity ) // Works also if we use extra space
        {
          setBlockLabel(size, label);
          return ( myData[size] = data );
        }
      else if ( size == blockMaxCapacity )
        {
          __NextBlock* next = new __NextBlock;

          // Move the extra space content to the next block.
          for ( std::size_t i = 0; i < extraSpace; ++i )
            {
              next->pushBack( getBlockValueAt(i + blockCapacity), i );
            }

          // Push the new value into the next block.
          myTail.nextBlock = next;
          return myTail.nextBlock->pushBack( label, data, extraSpace );
        }
      else // size > blockMaxCapacity
        {
          // Send the job to the next block.
          return myTail.nextBlock->pushBack( label, data, size - blockCapacity );
        }
    }

  /** Adds a (label,data) pair.
   * @param value   the (label,data) pair.
   * @param size    the current number of stored values in this block and the following.
   */
  inline
  Data& pushBack( Value const& value, std::size_t size )
    {
      return pushBack( value.first, value.second, size );
    }

  /** Removes the last data and returns it.
   * @param size  the current number of stored values in this blocks and the following.
   */
  inline
  Value popBack( std::size_t size )
    {
      ASSERT( size > 0 );

      if ( size <= blockMaxCapacity ) // Works also if we use extra space.
        {
          return getBlockValueAt(size-1);
        }
      else if ( size == blockMaxCapacity + 1)
        {
          __NextBlock* nextBlock = myTail.nextBlock;

          const Value value = nextBlock->popBack( extraSpace+1 );

          // Move the next block content into the extra space.
          for ( std::size_t i = blockCapacity; i < blockMaxCapacity; ++i )
            {
              setBlockValueAt( i, nextBlock->getBlockValueAt( i-blockCapacity ) );
            }

          delete nextBlock;
          return value;
        }
      else // size > blockMaxCapacity + 1
        {
          return myTail.nextBlock->popBack( size - blockCapacity );
        }
    }

  /** Removes the data at the given position.
   * @param idx   the position of the data.
   * @param size  the current number of stored values in this blocks and the following.
   */
  inline
  void eraseAt( std::size_t idx, std::size_t size )
    {
      ASSERT( idx < size );

      if ( idx == size-1 )
        {
          popBack( size );
        }
      else if ( size <= blockMaxCapacity ) // Works also if we use extra space.
        {
          setBlockValueAt( idx, getBlockValueAt(size-1) );
        }
      else if ( size == blockMaxCapacity + 1 )
        {
          __NextBlock* const nextBlock = myTail.nextBlock;

          if ( idx < blockCapacity )
            setBlockValueAt( idx, nextBlock->getBlockValueAt( size-blockCapacity-1 ) );
          else
            nextBlock->eraseAt( idx-blockCapacity, size-blockCapacity );

          // Move the next block content into the extra space.
          for ( std::size_t i = blockCapacity; i < blockMaxCapacity; ++i )
            {
              setBlockValueAt( i, nextBlock->getBlockValueAt( i-blockCapacity ) );
            }

          delete nextBlock;
        }
      else // size > blockMaxCapacity + 1
        {
          if ( idx < blockCapacity )
            setBlockValueAt( idx, myTail.nextBlock->popBack( size - blockCapacity ) );
          else
            myTail.nextBlock->eraseAt( idx - blockCapacity, size - blockCapacity );
        }
    }

  /** Gets reference to data from the corresponding label (mutable version).
   * The label is created if it doesn't exist.
   * @param label The label associated to the data.
   * @param size  The current number of stored value in this block and the following.
   * @param[out] found  If false, the label has not been found and a new element has been added. 
   */
  Data& getDataFromLabel ( Label const& label, std::size_t size, bool& found )
    {
      const std::size_t theBlockSize = blockSize(size);

      // Firstly search in this block
      for ( std::size_t i = 0; i < theBlockSize; ++i )
        {
          if ( getBlockLabel(i) == label )
            {
              found = true;
              return getBlockDataAt(i);
            }
        }

      // Then, search in the next block if there is one.
      if ( size > theBlockSize )
        {
          return getDataFromLabel( label, size - blockCapacity, found );
        }
      else
        {
          found = false;
          return pushBack( label, Data(), size );
        }
    }

  /** Gets reference to data from the corresponding label (constant version)
   * It the label does not exist, the referenced data is undefined.
   * @param label The label associated to the data.
   * @param size  The current number of stored value in this block and the following.
   * @param[out] found  If false, the label has not been found. 
   */
  Data const& getDataFromLabel ( Label const& label, std::size_t size, bool& found ) const
    {
      const std::size_t theBlockSize = blockSize(size);

      // Firstly search in this block
      for ( std::size_t i = 0; i < theBlockSize; ++i )
        {
          if ( getBlockLabel(i) == label )
            {
              found = true;
              return getBlockDataAt(i);
            }
        }

      // Then, search in the next block if there is one.
      if ( size > theBlockSize )
        {
          return getDataFromLabel( label, size - blockCapacity, found );
        }
      else
        {
          found = false;
          return Data();
        }
    }

  /** Search for a label in this block.
   * @param label The label to find.
   * @param size  The current number of stored value in this block and the following.
   * @param[out] found True if the label has been found, false otherwise.
   * @return the index of the label if found, otherwise returns the index of the label just after this block.
   */
  std::size_t findBlockLabel( Label const& label, std::size_t size, bool& found ) const
    {
      const std::size_t theBlockSize = blockSize( size );

      for ( std::size_t i = 0; i < theBlockSize; ++i )
        {
          if ( getBlockLabel(i) == label )
            {
              found = true;
              return i;
            }
        }

      found = false;
      return theBlockSize;
    }
  
  /** Clear this block and the following blocks.
   * @param size  The current number of stored value in this block and the following.
   */
  void clear( std::size_t size )
    {
      if ( size > blockMaxCapacity )
        {
          myTail.nextBlock->clear( size - blockCapacity );
          delete myTail.nextBlock;
        }
    }

  Labels myLabels; ///< Label storage.
  Data myData[ blockCapacity ]; ///< Data storage.
  DataOrBlockPointer myTail; ///< Extra space or pointer to the next block.
}; // end of class BigLabelledMap::__Block

///////////////////////////////////////////////////////////////////////////////
// class BigLabelledMap::IteratorBase
//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
template < typename TFirstBlock, typename TNextBlock >
class DGtal::BigLabelledMap<TData, L, N, M>::IteratorBase
{

public:

  /** Returns the label where this iterator points to.
   *
   * Useful if the pointed data is not needed.
   */
  inline
  Key getLabel () const
    {
      if ( myNextBlockStack.size() == 0 )
        {
          return myFirstBlock->getBlockLabel( this->myIndex );
        }
      else
        {
          return myNextBlockStack.back()->getBlockLabel( this->myIndex );
        }
    }

  /// Returns the index of the pointed element.
  inline
  SizeType getIndex () const
    {
      if ( myNextBlockStack.size() == 0 )
        {
          return myIndex;
        }
      else
        {
          return 
              TFirstBlock::blockCapacity
            + ( myNextBlockStack.size() - 1 ) * TNextBlock::blockCapacity
            + myIndex;
        }
    }

protected:

  friend class BigLabelledMap<TData, L, N, M>;

  // Boost iterator_facade core operations.
  friend class boost::iterator_core_access;

  /** Constructor.
   * @param aFirstBlock The first block of data.
   * @param aSize       The number of data stored in the container.
   * @param anIndex     The index where this iterator point to.
   */
  IteratorBase ( TFirstBlock& aFirstBlock, std::size_t aSize, std::size_t anIndex = 0 )
    : myFirstBlock( &aFirstBlock)
    , myIndex( 0 )
    , mySize( aSize )
  {
    advance( anIndex );
  }

  /** Interoperability constructor.
   * @tparam TOtherFirstBlock First block type of the other iterator.
   * @tparam TOtherNextBlock  Next block type of the other iterator.
   */
  template < 
    typename TOtherFirstBlock,
    typename TOtherNextBlock
  >
  IteratorBase ( IteratorBase< TOtherFirstBlock, TOtherNextBlock > const& other )
    : myFirstBlock( other.myFirstBlock )
    , myIndex( other.myIndex )
    , mySize( other.mySize )
  {
    std::copy( other.myNextBlockStack.begin(), other.myNextBlockStack.end(), std::back_inserter(myNextBlockStack) );
  }

  /// Destructor
  virtual ~IteratorBase()
    {
    }

  /// Increments of one position.
  inline void increment()
    {
      advance(1);
    }

  /// Decrements of one position.
  inline void decrement()
    {
      advance(-1);
    }

  /// Tests equality with other iterator.
  template < typename TOtherFirstBlock, typename TOtherNextBlock >
  inline bool equal( IteratorBase<TOtherFirstBlock, TOtherNextBlock> const& other ) const
    {
      return 
            myIndex == other.myIndex
        &&  mySize  == other.mySize
        &&  myNextBlockStack.size() == other.myNextBlockStack.size();
    }

  /// Distance to.
  template < typename TOtherFirstBlock, typename TOtherNextBlock >
  inline std::ptrdiff_t distance_to( IteratorBase<TOtherFirstBlock, TOtherNextBlock> const& other ) const
    {
      return other.myIndex - myIndex;
    }

  /// Advance by \p n positions.
  inline void advance ( DifferenceType n )
    {
      if ( n > 0 )
        {
          myIndex += n;

          if ( myNextBlockStack.size() > 0 || ! myFirstBlock->isInThisBlock( myIndex, mySize ) )
            {
              if ( myNextBlockStack.size() == 0 )
                {
                  myNextBlockStack.push_back( myFirstBlock->myTail.nextBlock );
                  myIndex -= TFirstBlock::blockCapacity;
                  mySize  -= TFirstBlock::blockCapacity;
                }

              while ( ! TNextBlock::isInThisBlock( myIndex, mySize ) )
                {
                  myNextBlockStack.push_back( myNextBlockStack.back()->myTail.nextBlock );
                  myIndex -= TNextBlock::blockCapacity;
                  mySize  -= TNextBlock::blockCapacity;
                }
            }
        }
      else 
        {
          n = -n; // For clarity of the following algo.

          while ( n > 0 )
            {
              if ( n <= myIndex )
                {
                  myIndex -= n;
                  n = 0;
                }
              else
                {
                  ASSERT( myNextBlockStack.size() > 0 );
                  n -= myIndex + 1;
                  myNextBlockStack.pop_back();
                  if ( myNextBlockStack.size() > 0 )
                    myIndex = mySize = TNextBlock::blockCapacity;
                  else
                    myIndex = mySize = TFirstBlock::blockCapacity;
                }
            }
        }
    }

protected:
  TFirstBlock* myFirstBlock;  ///< Pointer to the first block of data.
  std::size_t myIndex;        ///< Current index where this pointer points to.
  std::size_t mySize;         ///< Number of data stored after this pointer.
  std::deque< TNextBlock* > myNextBlockStack; ///< Stack of the next blocks of data before this pointer.
}; // End of class IteratorBase

///////////////////////////////////////////////////////////////////////////////
// class BigLabelledMap::Iterator
//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
class DGtal::BigLabelledMap<TData, L, N, M>::Iterator
  : public  IteratorBase< __FirstBlock, __NextBlock >
  , public  boost::iterator_facade <
      Iterator,
      Value,
      boost::random_access_traversal_tag,
      Reference
    >
{

public:
  /** Constructor.
   * @param aFirstBlock The first block of data.
   * @param aSize       The number of data stored in the container.
   * @param anIndex     The index where this iterator points to.
   */
  Iterator ( __FirstBlock& aFirstBlock, std::size_t aSize, std::size_t anIndex = 0 )
    : IteratorBase< __FirstBlock, __NextBlock >( aFirstBlock, aSize, anIndex )
  {
  }

  /** Returns a mutable reference to the data where this iterator points to.
   *
   * Only useful when the label is not needed.
   */
  Data& getData() const
    {
      if ( this->myNextBlockStack.size() == 0 )
        {
          return this->myFirstBlock->getBlockDataAt( this->myIndex );
        }
      else
        {
          return this->myNextBlockStack.back()->getBlockDataAt( this->myIndex );
        }
    }

private:
  
  // Boost iterator_facade core operations.
  friend class boost::iterator_core_access;

  /// Dereference.
  inline Reference dereference() const
    {
      if ( this->myNextBlockStack.size() == 0 )
        {
          return this->myFirstBlock->getBlockValueAt( this->myIndex );
        }
      else
        {
          return this->myNextBlockStack.back()->getBlockValueAt( this->myIndex );
        }
    }

}; // End of class Iterator.

///////////////////////////////////////////////////////////////////////////////
// class BigLabelledMap::ConstIterator
//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
class DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
  : public IteratorBase< const __FirstBlock, const __NextBlock >
  , public boost::iterator_facade <
      ConstIterator,
      const Value,
      boost::random_access_traversal_tag,
      ConstReference
    >
{
public:

  /** Constructor.
   * @param aFirstBlock The first block of data.
   * @param aSize       The number of data stored in the container.
   * @param anIndex     The index where this iterator points to.
   */
  ConstIterator ( __FirstBlock const& aFirstBlock, std::size_t aSize, std::size_t anIndex = 0 )
    : IteratorBase< const __FirstBlock, const __NextBlock >( aFirstBlock, aSize, anIndex )
    {
    }

  /// Interoperability constructor.
  ConstIterator ( Iterator const& other )
    : IteratorBase< const __FirstBlock, const __NextBlock >( other )
    {
    }

  /** Returns a constant reference to the data where this iterator points to.
   *
   * Only useful when the label is not needed.
   */
  Data const& getData() const
    {
      if ( this->myNextBlockStack.size() == 0 )
        {
          return this->myFirstBlock->getBlockDataAt( this->myIndex );
        }
      else
        {
          return this->myNextBlockStack.back()->getBlockDataAt( this->myIndex );
        }
    }

private:
  
  // Boost iterator_facade core operations.
  friend class boost::iterator_core_access;

  /// Dereference.
  inline ConstReference dereference() const
    {
      if ( this->myNextBlockStack.size() == 0 )
        {
          return this->myFirstBlock->getBlockValueAt( this->myIndex );
        }
      else
        {
          return this->myNextBlockStack.back()->getBlockValueAt( this->myIndex );
        }
    }

}; // End of class ConstIterator

///////////////////////////////////////////////////////////////////////////////
// class BigLabelledMap
//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
DGtal::BigLabelledMap<TData, L, N, M>::
BigLabelledMap()
{
  set_size(0);
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
DGtal::BigLabelledMap<TData, L, N, M>::
~BigLabelledMap()
{
  clear();
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
DGtal::BigLabelledMap<TData, L, N, M>::
BigLabelledMap( const BigLabelledMap & other )
{
  set_size(0);
  *this = other;
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
template <typename InputIterator>
inline
DGtal::BigLabelledMap<TData, L, N, M>::
BigLabelledMap( InputIterator it_begin, InputIterator it_end )
{
  BOOST_CONCEPT_ASSERT(( boost::InputIterator< InputIterator > ));

  set_size(0);
  for ( ; it_begin != it_end; ++it_begin )
    {
      (*this)[it_begin->first] = it_begin->second;
    }
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
DGtal::BigLabelledMap<TData, L, N, M> &
DGtal::BigLabelledMap<TData, L, N, M>::
operator=( const BigLabelledMap & other )
{
  if ( this != &other )
    {
      clear();
 
      myFirstBlock = other.myFirstBlock;

      std::size_t theSize = other.size();
      this->set_size( theSize ); // not necessary

      if ( ! myFirstBlock.isInThisBlock( theSize-1, theSize ) )
        {
          myFirstBlock.myTail.nextBlock = new __NextBlock( *other.myFirstBlock.myTail.nextBlock );
          __NextBlock* nextBlock = myFirstBlock.myTail.nextBlock;
          theSize -= __FirstBlock::blockCapacity;

          while ( ! nextBlock->isInThisBlock( theSize-1, theSize ) )
            {
              nextBlock->myTail.nextBlock = new __NextBlock( *(nextBlock->myTail.nextBlock) );
              nextBlock = nextBlock->myTail.nextBlock;
              theSize -= __NextBlock::blockCapacity;
            }
        }
    }
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
clear()
{
  myFirstBlock.clear( size() );
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
size() const
{
  return myFirstBlock.myLabels.getValue(0, SizeType(0));
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
void 
DGtal::BigLabelledMap<TData, L, N, M>::
set_size( SizeType aSize )
  {
    myFirstBlock.myLabels.setValue( 0, aSize );
  }

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator 
DGtal::BigLabelledMap<TData, L, N, M>::
push_back( Value const& aValue, Iterator hint )
  {
    hint.myIndex = 0;

    if ( hint.myNextBlockStack.size() == 0 )
      myFirstBlock.pushBack( aValue, hint.mySize );
    else
      hint.myNextBlockStack.back()->pushBack( aValue, hint.mySize );

    // Update size
    set_size( size() + 1 );

    // Update iterator to make it valid
    hint.mySize++;

    return hint += hint.mySize-1;
  }

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator 
DGtal::BigLabelledMap<TData, L, N, M>::
push_back( Value const& aValue )
{
  return push_back( aValue, begin() );
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
bool
DGtal::BigLabelledMap<TData, L, N, M>::
empty() const
{
  return size() == 0;
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
max_size() const
{
  return maxLabel;
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
capacity() const
{
  const SizeType theSize = size();
  if ( theSize <= __FirstBlock::blockMaxCapacity )
    {
      return __FirstBlock::blockMaxCapacity;
    }
  else
    {
      const SizeType theCapacity =
           __FirstBlock::blockCapacity
        + ( (theSize - __FirstBlock::blockCapacity) / __NextBlock::blockCapacity ) * __NextBlock::blockCapacity;
      
      if ( theSize - theCapacity <= __NextBlock::extraSpace )
        return theCapacity + __NextBlock::extraSpace;
      else
        return theCapacity + __NextBlock::blockMaxCapacity;
    }
}


//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
swap( Self & other )
{
  std::swap( myFirstBlock, other.myFirstBlock );
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
count( const Key & key ) const
{
  const ConstIterator it = find( key );
  return ( it != end() ) ? 1 : 0;
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Data const&
DGtal::BigLabelledMap<TData, L, N, M>::
at ( const Key & key ) const
{
  ASSERT( key < maxLabel ); 

  ConstIterator it = find( key );
  if ( it != end() )
    {
      return it.getData();
    }
  else
    {
      throw std::out_of_range( "Key not found." );
    }
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
at ( const Key & key )
{
  ASSERT( key < maxLabel ); 

  Iterator it = find( key );
  if ( it != end() )
    {
      return it.getData();
    }
  else
    {
      throw std::out_of_range( "Key not found." );
    }
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Data &
DGtal::BigLabelledMap<TData, L, N, M>::
operator[]( const Key & key )
{
  ASSERT( key < L ); 

  Iterator it = find( key );

  if ( it != end() )
    return it.getData();
  else
    return push_back( Value( key, Data() ) ).getData();

}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
erase( ConstIterator position )
{
  ASSERT( count( position->first ) == 1 );

  if ( position.myNextBlockStack.size() == 0 )
    {
      const_cast<__FirstBlock*>(position.myFirstBlock)->eraseAt( position.myIndex, position.mySize );
    }
  else
    {
      const_cast<__NextBlock*>(position.myNextBlockStack.back())->eraseAt( position.myIndex, position.mySize );
    }

  set_size( size() - 1 );
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::SizeType
DGtal::BigLabelledMap<TData, L, N, M>::
erase( Key const& key )
{
  const ConstIterator it = find( key );
  if ( it != end() )
    {
      erase(it);
      return 1;
    }
  else
    {
      return 0;
    }
}

//-----------------------------------------------------------------------------
/*
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
erase( ConstIterator first, ConstIterator last )
{
  for ( ; first != last; ++first )
    erase( first );
}
*/

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
std::pair<typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator, bool>
DGtal::BigLabelledMap<TData, L, N, M>::
insert( const Value & val )
{
  ASSERT( val.first < maxLabel ); 

  Iterator it = find( val.first );

  if ( it != end() )
    return std::make_pair( it, false );
  else
    return std::make_pair( push_back( val ), true );
    //return std::make_pair( push_back( val, --it ), true );
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
insert ( Iterator /* position */ , const Value & val )
{
  return insert( val ).first;
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
template <typename InputIterator>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
insert( InputIterator first, InputIterator last )
{ 
  BOOST_CONCEPT_ASSERT(( boost::InputIterator< InputIterator > ));
  
  for ( ; first != last; ++first )
    {
      insert( *first );
    }
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
std::pair< typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator,
           typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator >
DGtal::BigLabelledMap<TData, L, N, M>::
equal_range( const Key & key )
{
  const Iterator it_end = end();
  Iterator it = find( key );

  if ( it != it_end )
    {
      return std::make_pair( it, ++it );
    }
  else
    {
      return std::make_pair( it_end, it_end );
    }
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
std::pair< typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator,
           typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator >
DGtal::BigLabelledMap<TData, L, N, M>::
equal_range( const Key & key ) const
{
  const ConstIterator it_end = end();
  ConstIterator it = find( key );

  if ( it != it_end )
    {
      return std::make_pair( it, ++it );
    }
  else
    {
      return std::make_pair( it_end, it_end );
    }
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
find( const Key & key )
{
  Iterator it = begin();
  bool found = false;

  SizeType idx = it.myFirstBlock->findBlockLabel( key, it.mySize, found );
  it += idx;

  if ( found )
    {
      return it;
    }
  else
    {
      const Iterator it_end = end();
      while ( it != it_end )
        {
          idx = it.myNextBlockStack.back()->findBlockLabel( key, it.mySize, found ); 
          it += idx;
          if ( found )  return it;
        }

      return it;
    }
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
find( const Key & key ) const
{
  ConstIterator it = begin();
  bool found = false;

  SizeType idx = it.myFirstBlock->findBlockLabel( key, it.mySize, found );
  it += idx;

  if ( found )
    {
      return it;
    }
  else
    {
      const ConstIterator it_end = end();
      while ( it != it_end )
        {
          idx = it.myNextBlockStack.back()->findBlockLabel( key, it.mySize, found ); 
          it += idx;
          if ( found )  return it;
        }

      return it;
    }
}

//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
begin()
{
  return Iterator( myFirstBlock, size(), 0 );
}
//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::Iterator
DGtal::BigLabelledMap<TData, L, N, M>::
end()
{
  return Iterator( myFirstBlock, size(), size() );
}
//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
begin() const
{
  return ConstIterator( myFirstBlock, size(), 0 );
}
//-----------------------------------------------------------------------------
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
typename DGtal::BigLabelledMap<TData, L, N, M>::ConstIterator
DGtal::BigLabelledMap<TData, L, N, M>::
end() const
{
  return ConstIterator( myFirstBlock, size(), size() );
}


///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
void
DGtal::BigLabelledMap<TData, L, N, M>::
selfDisplay( std::ostream & out ) const
{
  if ( size() == 0 ) out << "()";
  else
    {
      ConstIterator it = begin();
      ConstIterator it_end = end();
      out << "( ";
      out << "(" << (*it).first << "," << (*it).second << ")";
      ++it;
      for ( ; it != it_end; ++it )
	{
          out << ",(" << (*it).first << "," << (*it).second << ")";
	}
      out << " )";
    }
    // {
    //   BlockConstIterator it = blockBegin();
    //   BlockConstIterator it_end = blockEnd();
    //   BlockConstIterator it_last = it;
    //   out << "(";
    //   out << *it;
    //   ++it;
    //   for ( ; it != it_end; ++it )
    //     {
    //       out << ( ( it_last.myDatas == it.myDatas ) ? ',' : ';' );
    //       out << *it;
    //       it_last = it;
    //     }
    //   out << ")";
    // }
}


/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
bool
DGtal::BigLabelledMap<TData, L, N, M>::isValid() const
{
    return true;
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TData, std::size_t L, std::size_t N, std::size_t M>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const DGtal::BigLabelledMap<TData, L, N, M> & object )
{
  object.selfDisplay( out );
  return out;
}

template <typename TData>
std::pair< unsigned int, unsigned int >
DGtal::detail::argminBigLabelledMapMemoryUsageForGeometricDistribution
( unsigned int L, double prob_no_data, double prob_one_data )
{
  unsigned int sL = 2 * ( ( ( L - 1 ) / 16 ) + 1 ); // word of 16bits
  // std::cerr << "L=" << L  << " sL=" << sL << std::endl;
  BigLabelledMapMemFunctor F( prob_one_data, prob_no_data, sL, sizeof( TData ),
                           sizeof( TData* ), 2 );
  double m = -1.0;
  std::size_t Nopt = 0;
  std::size_t Mopt = 0;
  for ( std::size_t N = 1; N < L; ++N )
    for ( std::size_t M = 2; M < (L-N); ++M )
      {
        // std::cerr << "Fmem(" << N << "," << M << ")=" 
        //           << F.fctNM( N, M ) << std::endl;
        if ( ( m < 0.0 ) || ( F.fctNM( N, M ) < m ) )
          {
            Nopt = N; Mopt = M; 
            m = F.fctNM( Nopt, Mopt );
          }
      }
  return std::make_pair( Nopt, Mopt );
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


